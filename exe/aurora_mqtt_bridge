#!/usr/bin/env ruby
# frozen_string_literal: true

require "aurora"
require "homie-mqtt"
require "ccutrer-serialport"
require "uri"
require "optparse"
require "yaml"
require "aurora/core_ext/string"

debug_modbus = mock = false

options = OptionParser.new do |opts|
  opts.banner = "Usage: aurora_mqtt_bridge /path/to/serial/port [options]"

  opts.on("--debug-modbus", "Print actual protocol bytes") { debug_modbus = true }
  opts.on("--mock",
          "Instead of talking to an actual heat pump, mock it with registers from the given YAML file (instead of a serial port)") do # rubocop:disable Layout/LineLength
    mock = true
  end
  opts.on("-h", "--help", "Prints this help") do
    puts opts
    exit
  end
end

options.parse!

unless ARGV.length == 2
  puts options
  exit 1
end

mqtt_uri = ARGV[1]

if mock
  slave = Aurora::MockABC.new(YAML.load_file(ARGV[0]))
else
  uri = URI.parse(ARGV[0])

  args = case uri.scheme
         when "tcp"
           require "socket"
           [TCPSocket.new(uri.host, uri.port)]
         when "telnet", "rfc2217"
           require "net/telnet/rfc2217"
           [Net::Telnet::RFC2217.new(uri.host,
                                     port: uri.port || 23,
                                     baud: 19_200,
                                     parity: :even)]
         else
           [CCutrer::SerialPort.new(uri.path, baud: 19_200, parity: :even)]
         end

  client = ModBus::RTUClient.new(*args)
  client.logger = Logger.new($stdout)
  client.logger.level = debug_modbus ? :debug : :warn

  slave = client.with_slave(1)
end

abc = Aurora::ABCClient.new(slave)

class MQTTBridge
  def initialize(abc, homie)
    @abc = abc
    @homie = homie
    @mutex = Mutex.new

    @homie.out_of_band_topic_proc = lambda do |topic, value|
      @mutex.synchronize do
        case topic
        when /\$modbus$/
          registers = @abc.query_registers(value)
          Aurora.print_registers(registers) do |register, v|
            @homie.mqtt.publish("#{@homie.topic}/$modbus/#{register}", v, retain: false, qos: 1)
          end
        when %r{\$modbus/(\d+)/set$}
          register = $1.to_i
          value = case value
                  when /\d+/
                    value.to_i
                  when /0x(\d+)/
                    $1.to_i(16)
                  end
          @abc.modbus_slave.holding_registers[register] = value if value
          registers = { register => @abc.modbus_slave.holding_registers[register] }
          Aurora.print_registers(registers) do |r, v|
            @homie.mqtt.publish("#{@homie.topic}/$modbus/#{r}", v, retain: false, qos: 1)
          end
        end
      end
    rescue StandardError => e
      warn "failed processing message: #{e}\n#{e.backtrace}"
    end

    @abc.refresh
    publish_basic_attributes

    loop do
      begin
        @mutex.synchronize do
          @abc.refresh
          @homie_abc.each do |property|
            property.value = @abc.public_send(property.id.tr("-", "_"))
          end

          @abc.faults.each_with_index do |fault_count, i|
            @faults["e#{i + 1}"].value = fault_count
          end

          @abc.zones.each_with_index do |z, idx|
            homie_zone = @homie["zone#{idx + 1}"]
            homie_zone.each do |property|
              property.value = z.public_send(property.id.tr("-", "_"))
            end
          end
        end
      rescue => e
        warn "got garbage: #{e}; #{e.backtrace}"
        exit 1
      end
      sleep(5)
    end
  end

  def publish_basic_attributes
    @homie_abc = @homie.node("abc", "Aurora Basic Control", "ABC") do |node|
      node.property("compressor-speed", "Compressor Speed", :integer, @abc.compressor_speed,
                    format: @abc.vs? ? 0..12 : 0..2)
      node.property("current-mode", "Current Heating/Cooling Mode", :enum, @abc.current_mode,
                    format: %w[lockout standby blower heating cooling eh1 eh2 emergency waiting dehumidify])
      if @abc.dhw?
        node.property("dhw-water-temperature", "DHW Water Temperature", :float, @abc.dhw_water_temperature, unit: "ºF")
      end
      node.property("entering-air-temperature", "Entering Air Temperature", :float, @abc.entering_air_temperature,
                    unit: "ºF")
      node.property("entering-water-temperature", "Entering Water Temperature", :float,
                    @abc.entering_water_temperature, unit: "ºF")
      node.property("fan-speed", "Fan Speed", :integer, @abc.fan_speed, format: 0..11)
      node.property("leaving-air-temperature", "Leaving Air Temperature", :float, @abc.leaving_air_temperature,
                    unit: "ºF")
      node.property("leaving-water-temperature", "Leaving Water Temperature", :float, @abc.leaving_water_temperature,
                    unit: "ºF")
      unless @abc.outdoor_temperature.zero? # TODO: figure out the config if this actually exists
        node.property("outdoor-temperature", "Outdoor Temperature", :float, @abc.outdoor_temperature, unit: "ºF")
      end
      node.property("relative-humidity", "Relative Humidity", :integer, @abc.relative_humidity, unit: "%",
                                                                                                format: 0..100)
      node.property("waterflow", "Waterflow", :float, unit: "gpm")
      node.property("fp1", "FP1 Sensor", :float, @abc.fp1, unit: "ºF")
      node.property("fp2", "FP2 Sensor", :float, @abc.fp2, unit: "ºF")
      %i[compressor blower aux_heat loop_pump total].each do |component|
        component = "#{component}_watts"
        node.property(component.tr("_", "-"), component.tr("_", " ").titleize, :integer,
                      @abc.public_send(component), unit: "W")
      end

      node.property("blower-only-ecm-speed", "Blower Only ECM Speed", :integer, @abc.blower_only_ecm_speed,
                    format: 1..12) do |value, property|
        @mutex.synchronize { property.value = @abc.blower_only_ecm_speed = value }
      end
      node.property("aux-heat-ecm-speed", "Aux Heat ECM Speed", :integer, @abc.aux_heat_ecm_speed,
                    format: 1..12) do |value, property|
        @mutex.synchronize { property.value = @abc.aux_heat_ecm_speed = value }
      end
    end

    @faults = @homie.node("faults", "Fault History", "ABC") do |node|
      @abc.faults.each_with_index do |count, i|
        name = Aurora::FAULTS[i + 1]
        node.property("e#{i + 1}", name || "E#{i + 1}", :integer, count)
      end
    end

    @abc.zones.each_with_index do |zone, i|
      type = zone.is_a?(Aurora::IZ2Zone) ? "IntelliZone 2 Zone" : "Thermostat"
      @homie.node("zone#{i + 1}", "Zone #{i + 1}", type) do |node|
        allowed_modes = %w[off auto cool heat]
        allowed_modes << "eheat" if i.zero?
        node.property("target-mode", "Target Heating/Cooling Mode", :enum, zone.target_mode,
                      format: allowed_modes) do |value, property|
          @mutex.synchronize { property.value = zone.target_mode = value.to_sym }
        end
        if zone.respond_to?(:current_mode) # TODO: implement for non-IZ2
          node.property("current-mode", "Current Heating/Cooling Mode Requested", :enum, zone.current_mode,
                        format: %w[standby h1 h2 h3 c1 c2])
        end
        node.property("target-fan-mode", "Target Fan Mode", :enum, zone.target_fan_mode,
                      format: %w[auto continuous intermittent]) do |value, property|
          @mutex.synchronize { property.value = zone.target_fan_mode = value.to_sym }
        end
        if zone.respond_to?(:current_fan_mode) # TODO: implement for non-IZ2
          node.property("current-fan-mode", "Current Fan Status", :boolean, zone.current_fan_mode)
          node.property("fan-intermittent-on", "Fan Intermittent Mode On Duration", :enum, zone.fan_intermittent_on,
                        unit: "M", format: %w[0 5 10 15 20]) do |value, property|
            @mutex.synchronize { property.value = zone.fan_intermittent_on = value.to_i }
          end
          node.property("fan-intermittent-off", "Fan Intermittent Mode Off Duration", :enum, zone.fan_intermittent_on,
                        unit: "M", format: %w[0 5 10 15 20 25 30 35 40]) do |value, property|
            @mutex.synchronize { property.value = zone.fan_intermittent_on = value.to_i }
          end
        end
        if zone.is_a?(Aurora::IZ2Zone)
          node.property("priority", "Zone Priority", :enum, zone.priority, format: %w[economy comfort])
          node.property("size", "Size", :enum, zone.size, format: %w[0 25 45 70])
          node.property("normalized-size", "Normalized Size", :integer, zone.normalized_size, unit: "%", format: 0..100)
        end
        node.property("ambient-temperature", "Ambient Temperature", :float, zone.ambient_temperature, unit: "ºF")
        node.property("heating-target-temperature", "Heating Target Temperature", :integer,
                      zone.heating_target_temperature, unit: "ºF", format: 40..90) do |value, property|
          @mutex.synchronize { property.value = zone.heating_target_temperature = value }
        end
        node.property("cooling-target-temperature", "Cooling Target Temperature", :integer,
                      zone.cooling_target_temperature, unit: "ºF", format: 54..99) do |value, property|
          @mutex.synchronize { property.value = zone.cooling_target_temperature = value }
        end
      end
    end

    # direct access to modbus registers for debugging purposes
    @homie.mqtt.subscribe("#{@homie.topic}/$modbus")
    @homie.mqtt.subscribe("#{@homie.topic}/$modbus/+/set")
    @homie.publish
  end
end

log_level = ARGV.include?("--debug") ? :debug : :warn
logger = Logger.new($stdout)
logger.level = log_level
slave.logger = logger

device = "aurora-#{abc.serial_number}"
homie = MQTT::Homie::Device.new(device, "Aurora MQTT Bridge", mqtt: mqtt_uri)
homie.logger = logger

MQTTBridge.new(abc, homie)
