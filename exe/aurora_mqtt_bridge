#!/usr/bin/env ruby
# frozen_string_literal: true

require "aurora"
require "homie-mqtt"
require "ccutrer-serialport"
require "uri"

uri = URI.parse(ARGV[0])
mqtt_uri = ARGV[1]

args = if uri.scheme == "telnet" || uri.scheme == "rfc2217"
         require "net/telnet/rfc2217"
         [Net::Telnet::RFC2217.new("Host" => uri.host,
                                   "Port" => uri.port || 23,
                                   "baud" => 19_200,
                                   "parity" => Net::Telnet::RFC2217::EVEN)]
       else
         [CCutrer::SerialPort.new(uri.path, baud: 19_200, parity: :even)]
       end

slave = ModBus::RTUClient.new(*args).with_slave(1)
abc = Aurora::ABCClient.new(slave)

class MQTTBridge
  def initialize(abc, homie)
    @abc = abc
    @homie = homie
    @mutex = Mutex.new

    @homie.instance_variable_set(:@block, lambda do |topic, value|
      @mutex.synchronize do
        case topic
        when /\$modbus$/
          query = value.split(",").map do |addr|
            case addr
            when "known"
              Aurora::REGISTER_NAMES.keys
            when /^(\d+)\.\.(\d+)$/
              Regexp.last_match(1).to_i..Regexp.last_match(2).to_i
            else
              addr.to_i
            end
          end
          queries = Aurora.normalize_ranges(query)
          registers = {}
          queries.each do |subquery|
            registers.merge!(@abc.modbus_slave.read_multiple_holding_registers(*subquery))
          end
          result = Aurora.print_registers(registers)
          @homie.mqtt.publish("#{@homie.topic}/$modbus/response", result, retain: false, qos: 1)
        when %r{\$modbus/(\d+)$}
          register = Regexp.last_match(1).to_i
          value = case value
                  when /\d+/
                    value.to_i
                  when /0x(\d+)/
                    Regexp.last_match(1).to_i(16)
                  end
          @abc.modbus_slave.holding_registers[register] = value if value
        end
      end
    rescue StandardError => e
      puts "failed processing message: #{e}\n#{e.backtrace}"
    end)

    publish_basic_attributes

    loop do
      begin
        @mutex.synchronize do
          @abc.refresh
          @homie_abc["compressor-speed"].value = @abc.compressor_speed
          @homie_abc["current-mode"].value = @abc.current_mode
          @homie_abc["dhw-water-temperature"].value = @abc.dhw_water_temperature
          @homie_abc["entering-air-temperature"].value = @abc.entering_air_temperature
          @homie_abc["entering-water-temperature"].value = @abc.entering_water_temperature
          @homie_abc["fan-speed"].value = @abc.fan_speed
          @homie_abc["leaving-air-temperature"].value = @abc.leaving_air_temperature
          @homie_abc["leaving-water-temperature"].value = @abc.leaving_water_temperature
          @homie_abc["outdoor-temperature"].value = @abc.outdoor_temperature
          @homie_abc["relative-humidity"].value = @abc.relative_humidity
          @homie_abc["waterflow"].value = @abc.waterflow
          @homie_abc["fp1"].value = @abc.fp1
          @homie_abc["fp2"].value = @abc.fp2

          @abc.iz2_zones.each do |z|
            homie_zone = @homie["zone#{z.zone_number}"]
            homie_zone["target-mode"].value = z.target_mode
            homie_zone["current-mode"].value = z.current_mode
            homie_zone["target-fan-mode"].value = z.target_fan_mode
            homie_zone["current-fan-mode"].value = z.current_fan_mode
            homie_zone["fan-intermittent-on"].value = z.fan_intermittent_on
            homie_zone["fan-intermittent-off"].value = z.fan_intermittent_off
            homie_zone["priority"].value = z.priority
            homie_zone["size"].value = z.size
            homie_zone["normalized-size"].value = z.normalized_size
            homie_zone["ambient-temperature"].value = z.ambient_temperature
            homie_zone["heating-target-temperature"].value = z.heating_target_temperature
            homie_zone["cooling-target-temperature"].value = z.cooling_target_temperature
          end
        end
      rescue => e
        puts "got garbage: #{e}; #{e.backtrace}"
        exit 1
      end
      sleep(5)
    end
  end

  def publish_basic_attributes
    @homie_abc = @homie.node("abc", "Aurora Basic Control", "ABC") do |node|
      node.property("compressor-speed", "Compressor Speed", :integer, @abc.compressor_speed, format: 0..1)
      node.property("current-mode", "Current Heating/Cooling Mode", :enum, @abc.current_mode,
                    format: %w[lockout standby blower h1 h2 c1 c2 eh1 eh2])
      node.property("dhw-water-temperature", "DHW Water Temperature", :float, @abc.dhw_water_temperature, unit: "ºF")
      node.property("entering-air-temperature", "Entering Air Temperature", :float, @abc.entering_air_temperature,
                    unit: "ºF")
      node.property("entering-water-temperature", "Entering Water Temperature", :float,
                    @abc.entering_water_temperature, unit: "ºF")
      node.property("fan-speed", "Fan Speed", :integer, @abc.fan_speed, format: 0..11)
      node.property("leaving-air-temperature", "Leaving Air Temperature", :float, @abc.leaving_air_temperature,
                    unit: "ºF")
      node.property("leaving-water-temperature", "Leaving Water Temperature", :float, @abc.leaving_water_temperature,
                    unit: "ºF")
      node.property("outdoor-temperature", "Outdoor Temperature", :float, @abc.outdoor_temperature, unit: "ºF")
      node.property("relative-humidity", "Relative Humidity", :integer, @abc.relative_humidity, unit: "%",
                                                                                                format: 0..100)
      node.property("waterflow", "Waterflow", :float, unit: "gpm")
      node.property("fp1", "FP1 Sensor", :float, @abc.fp1, unit: "ºF")
      node.property("fp2", "FP2 Sensor", :float, @abc.fp2, unit: "ºF")
    end

    @abc.iz2_zones.each do |zone|
      @homie.node("zone#{zone.zone_number}", "Zone #{zone.zone_number}", "IntelliZone 2 Zone") do |node|
        allowed_modes = %w[off auto cool heat]
        allowed_modes << "eheat" if zone.zone_number == 1
        node.property("target-mode", "Target Heating/Cooling Mode", :enum, zone.target_mode,
                      format: allowed_modes) do |value, property|
          @mutex.synchronize { property.value = zone.target_mode = value.to_sym }
        end
        node.property("current-mode", "Current Heating/Cooling Mode Requested", :enum, zone.current_mode,
                      format: %w[standby h1 h2 h3 c1 c2])
        node.property("target-fan-mode", "Target Fan Mode", :enum,  zone.target_fan_mode,
                      format: %w[auto continuous intermittent]) do |value, property|
          @mutex.synchronize { property.value = zone.target_fan_mode = value.to_sym }
        end
        node.property("current-fan-mode", "Current Fan Status", :boolean, zone.current_fan_mode)
        node.property("fan-intermittent-on", "Fan Intermittent Mode On Duration", :enum, zone.fan_intermittent_on,
                      unit: "M", format: %w[0 5 10 15 20]) do |value, property|
          @mutex.synchronize { property.value = zone.fan_intermittent_on = value.to_i }
        end
        node.property("fan-intermittent-off", "Fan Intermittent Mode Off Duration", :enum, zone.fan_intermittent_on,
                      unit: "M", format: %w[0 5 10 15 20 25 30 35 40]) do |value, property|
          @mutex.synchronize { property.value = zone.fan_intermittent_on = value.to_i }
        end
        node.property("priority", "Zone Priority", :enum, zone.priority, format: %w[economy comfort])
        node.property("size", "Size", :enum, zone.size, format: %w[0 25 45 70])
        node.property("normalized-size", "Normalized Size", :integer, zone.normalized_size, unit: "%", format: 0..100)
        node.property("ambient-temperature", "Ambient Temperature", :float, zone.ambient_temperature, unit: "ºF")
        node.property("heating-target-temperature", "Heating Target Temperature", :integer,
                      zone.heating_target_temperature, unit: "ºF", format: 40..90) do |value, property|
          @mutex.synchronize { property.value = zone.heating_target_temperature = value }
        end
        node.property("cooling-target-temperature", "Cooling Target Temperature", :integer,
                      zone.cooling_target_temperature, unit: "ºF", format: 54..99) do |value, property|
          @mutex.synchronize { property.value = zone.cooling_target_temperature = value }
        end
      end
    end

    # direct access to modbus registers for debugging purposes
    @homie.mqtt.subscribe("#{@homie.topic}/$modbus")
    @homie.mqtt.subscribe("#{@homie.topic}/$modbus/+")
    @homie.publish
  end
end

MQTTBridge.new(abc, MQTT::Homie::Device.new("aurora", "Aurora MQTT Bridge", mqtt: mqtt_uri))
